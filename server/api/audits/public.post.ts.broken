import type { H3Event } from 'h3'
import { createSupabaseClient } from '~/server/utils/supabase'
import { logger } from '~/server/utils/logger'
import { checkIPRateLimit, setRateLimitHeaders } from '~/server/utils/secureRateLimit'

// Request size limit (1MB)
const MAX_REQUEST_SIZE = 1024 * 1024

interface AuditRequest {
  url: string
}

export default defineEventHandler(async (event: H3Event) => {
  try {
    // Check request size
    const contentLength = getHeader(event, 'content-length')
    if (contentLength && parseInt(contentLength) > MAX_REQUEST_SIZE) {
      throw createError({
        statusCode: 413,
        statusMessage: 'Request too large'
      })
    }

    // IP-based rate limiting
    const rateLimitResult = await checkIPRateLimit(event)
    setRateLimitHeaders(event, rateLimitResult)
    
    if (!rateLimitResult.allowed) {
      const statusMessage = rateLimitResult.blocked 
        ? 'IP temporarily blocked due to repeated violations'
        : 'Too many requests. Please try again later.'
        
      throw createError({
        statusCode: 429,
        statusMessage
      })
    }

    // Validate and sanitize request body
    const body = await readBody(event) as AuditRequest
    const validatedData = validateAuditRequest(body)

    // Additional security checks
    const clientIP = getClientIP(event)
    const userAgent = getHeader(event, 'user-agent') || 'unknown'
    
    // Log security-relevant request
    logger.info('Public audit request', {
      url: validatedData.url,
      ip: clientIP,
      userAgent: userAgent.substring(0, 100) // Limit UA length
    })

    // Create audit record
    const supabase = createSupabaseClient()
    
    // Use a fixed UUID for public audits (you can generate one and reuse it)
    const PUBLIC_USER_UUID = '00000000-0000-0000-0000-000000000001'
    
    const { data: audit, error } = await supabase
      .from('audits')
      .insert({
        url: validatedData.url,
        user_id: PUBLIC_USER_UUID,
        status: 'pending',
        created_at: new Date().toISOString()
      })
      .select('id, url, status, created_at')
      .single()

    if (error) {
      logger.error('Database error during audit creation', error, {
        url: validatedData.url,
        ip: clientIP
      })
      
      throw createError({
        statusCode: 500,
        statusMessage: 'Failed to create audit. Please try again.'
      })
    }

    // Success response
    return {
      success: true,
      audit: {
        id: audit.id,
        url: audit.url,
        status: audit.status,
        created_at: audit.created_at
      }
    }
    
  } catch (error: any) {
    // Secure error logging - don't expose sensitive details
    if (error.statusCode) {
      // Known HTTP errors
      logger.warn('Public audit API error', {
        statusCode: error.statusCode,
        message: error.statusMessage,
        ip: getClientIP(event)
      })
      throw error
    } else {
      // Unexpected errors
      logger.error('Unexpected error in public audit API', error, {
        ip: getClientIP(event)
      })
      
      throw createError({
        statusCode: 500,
        statusMessage: 'Internal server error. Please try again.'
      })
    }
  }
})

function validateAuditRequest(body: any): AuditRequest {
  if (!body || typeof body !== 'object') {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid request body'
    })
  }

  const { url } = body

  // Validate URL
  if (!url || typeof url !== 'string') {
    throw createError({
      statusCode: 400,
      statusMessage: 'URL is required and must be a string'
    })
  }

  // Sanitize and validate URL
  const sanitizedUrl = sanitizeUrl(url.trim())
  if (!isValidUrl(sanitizedUrl)) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Please enter a valid website URL (e.g., example.com)'
    })
  }

  return {
    url: sanitizedUrl
  }
}

function sanitizeUrl(input: string): string {
  try {
    // Remove any potential XSS attempts
    let url = input.replace(/[<>'"]/g, '')
    
    // Add protocol if missing
    if (!url.match(/^https?:\/\//)) {
      url = 'https://' + url
    }
    
    // Parse and validate
    const urlObject = new URL(url)
    
    // Security: Only allow HTTP/HTTPS
    if (!['http:', 'https:'].includes(urlObject.protocol)) {
      throw new Error('Invalid protocol')
    }
    
    // Security: Block localhost and private IPs for public audits
    if (isPrivateIP(urlObject.hostname)) {
      throw new Error('Private URLs not allowed')
    }
    
    return urlObject.toString()
    
  } catch (error) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid URL format'
    })
  }
}

function isValidUrl(input: string): boolean {
  try {
    const url = new URL(input)
    
    // Must have valid protocol
    if (!['http:', 'https:'].includes(url.protocol)) {
      return false
    }
    
    // Must have valid hostname
    if (!url.hostname || url.hostname.length < 3) {
      return false
    }
    
    // Check for valid TLD
    const validTLD = /\.(com|org|net|edu|gov|mil|int|co|io|ai|app|dev|tech|biz|info|name|pro|museum|travel|jobs|mobi|tel|asia|cat|coop|xxx|post|geo|ly|me|tv|cc|tk|ml|ga|cf|ws|be|to|it|fr|de|uk|us|ca|au|jp|cn|in|br|mx|es|ru|nl|se|no|dk|fi|pl|cz|at|ch|gr|pt|ie|hu|bg|ro|hr|si|sk|lt|lv|ee|is|lu|mt|cy|ad|mc|sm|va|li|fo|gi|im|je|gg|ax|wf|pf|nc|vu|to|nu|nf|ck|pw|fm|mh|ki|nr|tv|ws|as|gu|mp|pr|vi|um)$/i
    
    return validTLD.test(url.hostname)
    
  } catch (error) {
    return false
  }
}

function isPrivateIP(hostname: string): boolean {
  // Block localhost
  if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname === '::1') {
    return true
  }
  
  // Block private IP ranges
  const privateRanges = [
    /^10\./,                    // 10.0.0.0/8
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./, // 172.16.0.0/12
    /^192\.168\./,              // 192.168.0.0/16
    /^169\.254\./,              // 169.254.0.0/16 (link-local)
    /^fc00:/i,                  // IPv6 unique local
    /^fe80:/i                   // IPv6 link-local
  ]
  
  return privateRanges.some(range => range.test(hostname))
}

function getClientIP(event: H3Event): string {
  const headers = [
    'cf-connecting-ip',
    'x-forwarded-for',
    'x-real-ip',
    'x-client-ip'
  ]
  
  for (const header of headers) {
    const value = getHeader(event, header)
    if (value) {
      const ip = value.split(',')[0].trim()
      if (isValidIP(ip)) {
        return ip
      }
    }
  }
  
  return 'unknown'
}

function isValidIP(ip: string): boolean {
  const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
  const ipv6 = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::1$|^::$/
  
  return ipv4.test(ip) || ipv6.test(ip)
}
